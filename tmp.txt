import pandas as pd
import os
import warnings
import re
import sys

# ==============================================================================
# CONFIGURAÇÕES
# ==============================================================================
ANO = "2025"
MES_ANO = "11-2025"
TETO_VALOR_ACEITAVEL = 5000000.00 

LISTA_EMPRESAS = [
    "DROGARIA LIMEIRA",
    "DROGARIA MORELLI FILIAL",
    "DROGARIA MORELLI MTZ"
]

OPCOES_BASE = [
    fr"N:\Matriz-Jds\Arquivos NF-e\{ANO}\{MES_ANO}",
    fr"N:\Arquivos NF-e\{ANO}\{MES_ANO}",
    fr"N:\{ANO}\{MES_ANO}"
]

DIR_SAIDA_RPA = r"V:\Fiscal\RPA"
KEYWORD_DOMINIO = "DOMINIO"
KEYWORD_EMPRESA = "EMPRESA"

warnings.filterwarnings('ignore')

try:
    import xlrd
except ImportError:
    xlrd = None

# ==============================================================================
# 1. FUNÇÕES DE LIMPEZA E VALIDAÇÃO
# ==============================================================================

def converter_para_float(texto):
    if pd.isna(texto) or str(texto).strip() == "": return 0.0
    if isinstance(texto, (int, float)): return float(texto)
    t = str(texto).strip()
    t = re.sub(r'[^\d.,-]', '', t)
    if not t: return 0.0
    if ',' in t and '.' in t:
        if t.find(',') > t.find('.'): t = t.replace('.', '').replace(',', '.')
        else: t = t.replace(',', '')
    elif ',' in t: t = t.replace(',', '.')
    try: 
        val = float(t)
        if val > TETO_VALOR_ACEITAVEL: return 0.0
        return val
    except: return 0.0

def normalizar_nota(nota):
    if pd.isna(nota): return "S/N"
    try: 
        so_numeros = re.sub(r'[^\d.]', '', str(nota))
        if not so_numeros: return "S/N"
        val = float(so_numeros)
        if val <= 0: return "S/N"
        return str(int(val))
    except: return str(nota).strip()

def coluna_parece_indice(serie):
    """
    Detecta se a coluna é apenas um contador de linhas (1, 2, 3...)
    para não confundir com o número da Nota Fiscal.
    """
    try:
        # Pega os primeiros 15 valores numéricos
        vals = pd.to_numeric(serie, errors='coerce').dropna().head(15).tolist()
        if len(vals) < 5: return False
        
        # Verifica se são pequenos (notas fiscais geralmente são > 100)
        media = sum(vals) / len(vals)
        if media < 50: 
            return True # É índice (1, 2, 3...)
            
        # Verifica se é perfeitamente sequencial
        diferencas = [vals[i+1] - vals[i] for i in range(len(vals)-1)]
        if all(d == 1 for d in diferencas):
            return True # É índice
            
        return False
    except:
        return False

# ==============================================================================
# 2. LEITURA
# ==============================================================================

def ler_arquivo_na_rede(caminho_arquivo):
    nome_arq = os.path.basename(caminho_arquivo)
    print(f"    ...Lendo: {nome_arq}")
    try:
        with open(caminho_arquivo, 'rb') as f: raw_bytes = f.read()
    except Exception as e:
        print(f"       [ERRO I/O] {e}")
        return None

    # XLRD
    if xlrd:
        try:
            wb = xlrd.open_workbook(file_contents=raw_bytes, on_demand=True, logfile=open(os.devnull, 'w'))
            sheet = wb.sheet_by_index(0)
            dados = [sheet.row_values(i) for i in range(sheet.nrows)]
            return pd.DataFrame(dados)
        except: pass 

    # REGEX FALLBACK
    try:
        texto = raw_bytes.decode('latin1', errors='ignore').replace('\x00', '')
        # Tenta HTML
        dfs = pd.read_html(texto, decimal=',', thousands='.')
        if dfs: return dfs[0]
        # Tenta Regex Linhas
        linhas = texto.splitlines()
        if len(linhas) < 5: linhas = re.split(r'\s{3,}', texto)
        dados = [re.findall(r'[\d.,]+', l) for l in linhas if len(l) > 10]
        return pd.DataFrame([d for d in dados if len(d) >= 2])
    except: pass
    return None

# ==============================================================================
# 3. PREPARAÇÃO (SELEÇÃO INTELIGENTE DE COLUNA)
# ==============================================================================

def localizar_inicio_tabela(df):
    if df is None or df.empty: return df
    print("       -> Varrendo cabeçalho...")
    for i in range(min(30, len(df))):
        linha_texto = " ".join(df.iloc[i].astype(str).str.lower().tolist())
        # Critério: Tem que ter "nota" E ("valor" ou "total")
        if ("nota" in linha_texto or "n.º" in linha_texto) and ("valor" in linha_texto or "total" in linha_texto):
            print(f"          [OK] Cabeçalho na linha {i+1}")
            df.columns = df.iloc[i].astype(str).str.strip()
            return df[i+1:].copy()
    return df

def preparar_dataframe(df_raw, tipo_origem):
    if df_raw is None or df_raw.empty: return pd.DataFrame(columns=["Nota", "Valor"])

    # Se veio do Regex manual (lista de numeros), tenta salvar
    if isinstance(df_raw.columns[0], int):
        df_raw = localizar_inicio_tabela(df_raw)

    # Padroniza nomes
    df_raw.columns = df_raw.columns.astype(str).str.lower().str.strip()
    
    col_nota = None
    col_valor = None
    col_cod = None

    print(f"       -> [{tipo_origem}] Selecionando colunas...")

    # --- ESTRATÉGIA DE SELEÇÃO ---
    candidatas_nota = []
    
    # 1. Identifica todas as colunas possíveis para NOTA
    for col in df_raw.columns:
        # Se for Domínio
        if tipo_origem == "DOMINIO":
            if "código" in col or "codigo" in col: col_cod = col
            if "nota" in col and "valor" not in col: candidatas_nota.append(col)
            if "valor contábil" in col or "valor contabil" in col: col_valor = col
        
        # Se for Empresa
        else:
            if "n.nota" in col or "n. nota" in col: candidatas_nota.append(col) # Prioridade máxima
            elif "nota" in col and "valor" not in col and "total" not in col: candidatas_nota.append(col)
            if "total nota" in col: col_valor = col

    # 2. Filtra a coluna de Nota correta (Anti-Índice)
    for cand in candidatas_nota:
        if not coluna_parece_indice(df_raw[cand]):
            col_nota = cand
            break # Achou uma nota que não é 1,2,3...
        else:
            print(f"          [FILTRO] Coluna '{cand}' ignorada (parece índice).")

    # Fallback Valor
    if not col_valor:
        cands = [c for c in df_raw.columns if "valor" in c or "total" in c or "vlr" in c]
        if cands: col_valor = cands[-1]

    # Último recurso se não achou nada
    if not col_nota: col_nota = df_raw.columns[0]
    if not col_valor: col_valor = df_raw.columns[-1]

    print(f"          [MAPA] Nota: '{col_nota}' | Valor: '{col_valor}'")

    # Extração
    try:
        cols = [col_nota, col_valor]
        if col_cod: cols.insert(0, col_cod)
        
        df_new = df_raw[cols].copy()
        
        # Renomeia
        if col_cod: df_new.columns = ["Codigo", "Nota", "Valor"]
        else: 
            df_new.columns = ["Nota", "Valor"]
            df_new["Codigo"] = "" # Cria vazia
            
    except:
        return pd.DataFrame(columns=["Codigo", "Nota", "Valor"])

    # Limpeza
    df_new["Nota"] = df_new["Nota"].apply(normalizar_nota)
    df_new["Valor"] = df_new["Valor"].apply(converter_para_float)
    
    # Filtra inválidos
    df_new = df_new[
        (df_new["Valor"] > 0.01) & 
        (df_new["Valor"] < TETO_VALOR_ACEITAVEL) &
        (df_new["Nota"] != "S/N") & 
        (df_new["Nota"] != "0")
    ]
    
    # Debug: Mostra as primeiras notas para você conferir no log
    if not df_new.empty:
        print(f"          -> Amostra Notas: {df_new['Nota'].head(3).tolist()}")
    
    return df_new.groupby("Nota", as_index=False).agg({"Valor": "sum", "Codigo": "first"})

# ==============================================================================
# 4. PROCESSAMENTO FINAL
# ==============================================================================

def processar_empresa(empresa, pasta_base):
    print(f"\n==================================================")
    print(f"EMPRESA: {empresa}")
    path_rpa = os.path.join(pasta_base, empresa, "ESCRITA FISCAL", "RELATORIO RPA")
    
    f_dom = f_emp = None
    if os.path.exists(path_rpa):
        for f in os.listdir(path_rpa):
            if KEYWORD_DOMINIO in f.upper() and f.endswith(('.xls', '.xlsx')): f_dom = os.path.join(path_rpa, f)
            if KEYWORD_EMPRESA in f.upper() and f.endswith(('.xls', '.xlsx')): f_emp = os.path.join(path_rpa, f)

    if not f_dom or not f_emp:
        print("[PULADO] Arquivos não encontrados.")
        return

    df_d = preparar_dataframe(ler_arquivo_na_rede(f_dom), "DOMINIO")
    df_e = preparar_dataframe(ler_arquivo_na_rede(f_emp), "EMPRESA")

    if df_d.empty and df_e.empty: 
        print("[ERRO] Dados insuficientes.")
        return

    # Cruzamento
    df_final = pd.merge(df_d, df_e, on="Nota", how="outer", suffixes=('_Dom', '_Emp'), indicator=True)
    
    # Preenche vazios
    df_final['Valor_Dom'] = df_final['Valor_Dom'].fillna(0.0)
    df_final['Valor_Emp'] = df_final['Valor_Emp'].fillna(0.0)
    
    # Unifica código (prioridade Domínio)
    if 'Codigo_Dom' in df_final.columns:
        df_final['Codigo'] = df_final['Codigo_Dom'].fillna(df_final['Codigo_Emp'])
    elif 'Codigo' not in df_final.columns:
        df_final['Codigo'] = ""
    
    df_final["Diferenca"] = df_final["Valor_Dom"] - df_final["Valor_Emp"]
    
    df_final["Status"] = df_final.apply(lambda r: 
        "Só Domínio" if r['_merge'] == 'left_only' else 
        ("Só Empresa" if r['_merge'] == 'right_only' else 
        ("Divergência Valor" if abs(r['Diferenca']) > 0.05 else "OK")), axis=1)
    
    # Seleciona Colunas Finais
    cols_finais = ['Codigo', 'Nota', 'Valor_Dom', 'Valor_Emp', 'Diferenca', 'Status']
    df_final = df_final[[c for c in cols_finais if c in df_final.columns]]
    
    try:
        df_final["k"] = pd.to_numeric(df_final["Nota"])
        df_final.sort_values("k", inplace=True)
        df_final.drop(columns="k", inplace=True)
    except: df_final.sort_values("Nota", inplace=True)

    # Salva
    os.makedirs(DIR_SAIDA_RPA, exist_ok=True)
    fname = f"Conciliacao_{empresa.replace(' ', '_')}_{MES_ANO}.xlsx"
    fout = os.path.join(DIR_SAIDA_RPA, fname)
    
    while True:
        try:
            with pd.ExcelWriter(fout, engine='xlsxwriter') as writer:
                df_final.to_excel(writer, index=False, sheet_name='Resultado')
                wb, ws = writer.book, writer.sheets['Resultado']
                fmt_m = wb.add_format({'num_format': '#,##0.00'})
                fmt_r = wb.add_format({'bg_color': '#FFC7CE', 'font_color': '#9C0006'})
                fmt_y = wb.add_format({'bg_color': '#FFEB9C', 'font_color': '#9C6500'})
                fmt_b = wb.add_format({'bg_color': '#BDD7EE', 'font_color': '#000000'})
                
                ws.set_column('A:B', 12)
                ws.set_column('C:E', 18, fmt_m)
                ws.set_column('F:F', 25)
                
                ws.conditional_format('F2:F9999', {'type':'text', 'criteria':'containing', 'value':'Divergência', 'format':fmt_r})
                ws.conditional_format('F2:F9999', {'type':'text', 'criteria':'containing', 'value':'Só Domínio', 'format':fmt_y})
                ws.conditional_format('F2:F9999', {'type':'text', 'criteria':'containing', 'value':'Só Empresa', 'format':fmt_b})

            print(f"    [SUCESSO] Salvo: {fname}")
            break
        except PermissionError:
            print(f"\n    !!! ARQUIVO ABERTO: {fname} !!!")
            input("    Feche o Excel e pressione ENTER...")
        except Exception as e:
            print(f"    [ERRO SALVAR] {e}")
            break

if __name__ == "__main__":
    print("--- INICIANDO RPA (V34 - CORRETOR DE COLUNA) ---")
    base = None
    for p in OPCOES_BASE:
        if os.path.exists(p): base = p; break
    if base:
        for e in LISTA_EMPRESAS: processar_empresa(e, base)
    else:
        print("[ERRO FATAL] Pasta base não encontrada.")
    print("\n--- FIM ---")
